/********************************************
 * УРОК: Функции в JavaScript
 ********************************************
 Функции — это основные строительные блоки в JS.
 Они позволяют объединять инструкции в единый блок,
 который можно многократно вызывать.
 ********************************************/

/*---------------------------------------------------
  1. Способы объявления функций
---------------------------------------------------
В JavaScript есть несколько способов объявить функцию:
1) Function Declaration — классический способ
2) Function Expression — функция как значение переменной
3) Стрелочные функции (Arrow Functions)
*/


// 1) Function Declaration
function greet(name) {
    console.log("Привет, " + name + age);
}

const user = {
    name: "Ivan",
    age: 12,
    sayName(){
        console.log("name " + this.name + this.age)
    }
}

user.sayName()


greet("Иван");

// 2) Function Expression
const greetExp = function(name) {
    console.log("Привет из выражения, " + name);
};
greetExp("Мария");

// 3) Стрелочная функция (короче синтаксис)
const greetArrow = (name) => {
    console.log("Привет из стрелочной функции, " + name);
};
greetArrow("Андрей");

// Теория:
// - Function Declaration можно вызывать до объявления (поднимается — hoisting)
// - Function Expression и стрелочные функции создаются только после строки с их объявлением
// - Стрелочные функции НЕ имеют своего this, часто используются для колбэков

/*---------------------------------------------------
  2. Параметры и аргументы
---------------------------------------------------
Параметры — это переменные внутри функции.
Аргументы — это реальные значения, переданные при вызове.
*/

function sum(a, b) {
    console.log("a:", a, "b:", b);
    return a + b;
}

const result2 = sum(5, 3)
console.log("Сумма:", result2);

// Параметры по умолчанию
function multiply(a, b = 1) {
    return a * b;
}
const result3 = multiply(4)
console.log("Умножение с параметром по умолчанию:", multiply(4));

/*---------------------------------------------------
  3. Возвращаемое значение
---------------------------------------------------
Функция может вернуть результат с помощью return.
*/

function square(x) {
    return x*x
}

let result = square(6);
console.log("Квадрат числа 6:", result);

// Если return не указан, функция возвращает undefined

/*---------------------------------------------------
  4. Замыкания
---------------------------------------------------
Замыкание — это функция, которая "запоминает"
своё лексическое окружение (переменные извне).
*/

function makeCounter() {
    let count = 0;
    return function() {
        count++;
        return count;
    };
}

let counter1 = makeCounter();
console.log("Счётчик 1:", counter1()); // 1
console.log("Счётчик 1:", counter1()); // 2

let counter2 = makeCounter();
console.log("Счётчик 2:", counter2()); // 1

// Теория:
// - Каждый вызов makeCounter создаёт свою "копию" окружения
// - Замыкания позволяют хранить состояние между вызовами функции

/*---------------------------------------------------
  5. Передача функций как аргументы (колбэки)
---------------------------------------------------
Функции в JS — это "первоклассные объекты".
Их можно передавать как аргументы другим функциям.
*/

function processUserInput(callback) {
    let name = "Ольга";
    callback(name);
}

function myPrint  (name){
    console.log(name)
}

processUserInput(myPrint)

// Передаём анонимную функцию
processUserInput(function(user) {
    console.log("Привет, " + user);
});

// Или стрелочную
processUserInput(user => console.log("Привет из стрелки, " + user));

/*---------------------------------------------------
  Таймеры: setTimeout и setInterval
---------------------------------------------------
В JavaScript есть встроенные функции для работы со временем:
- setTimeout — запускает функцию один раз через указанное время (в миллисекундах).
- setInterval — запускает функцию многократно через указанный интервал времени.

Обе функции возвращают ID таймера, который можно использовать для остановки.
*/

// setTimeout
console.log("Старт программы");

setTimeout(() => {
    console.log("Сообщение через 2 секунды");
}, 2000);

console.log("Остальной код продолжает выполняться, не дожидаясь таймера");

/*
Теория:
- setTimeout запускает указанную функцию ОДИН РАЗ после задержки.
- Задержка указывается в миллисекундах (1000 = 1 секунда).
- Код не «замораживается» — JS продолжает выполнять другие инструкции.
*/

// setInterval
let counter = 0;

let intervalId = setInterval(() => {
    counter++;
    console.log("Интервал сработал:", counter);

    if (counter >= 5) {
        clearInterval(intervalId); // останавливаем повторение
        console.log("Интервал остановлен");
    }
}, 1000);

/*
Теория:
- setInterval выполняет функцию ПОСТОЯННО через указанный интервал.
- Для остановки используется clearInterval(id).
- setTimeout можно отменить с помощью clearTimeout(id).
- Использовать setInterval нужно осторожно: если код внутри выполняется дольше, чем сам интервал, таймеры могут "накладываться".
*/

/*---------------------------------------------------
  Важное про Event Loop (цикл событий)
---------------------------------------------------
setTimeout и setInterval работают через механизм Event Loop.
Это значит:
- Таймеры не выполняются "точно в срок", а попадают в очередь задач.
- Если основной поток занят, выполнение задержится.
Пример: setTimeout(..., 0) не выполнится мгновенно,
а только после завершения текущего кода.
*/

setTimeout(() => {
    console.log("setTimeout с 0 задержкой всё равно выполняется после текущего кода");
}, 0);

console.log("Этот лог выполнится раньше, чем setTimeout(..., 0)");

/*---------------------------------------------------
  6. Асинхронные функции (async/await)
---------------------------------------------------
JavaScript однопоточный язык. Это значит, что он может выполнять
только одну инструкцию за раз. Но что делать, если у нас задача,
которая занимает время? Например:
- загрузка данных с сервера
- ожидание ответа от базы данных
- таймеры и задержки
Чтобы не "замораживать" весь код, придуманы асинхронные операции.

async/await — современный синтаксис для работы с асинхронностью.

1) async перед функцией делает её асинхронной и автоматически возвращает Promise.
2) await внутри async-функции приостанавливает выполнение до завершения Promise.

Пример: задержка с помощью setTimeout, обёрнутого в Promise.
*/

function delay(ms) {
    // возвращаем новый Promise, который "резолвится" через ms миллисекунд
    return new Promise(resolve => setTimeout(resolve, ms));
}

async function asyncExample() {
    console.log("Начало работы функции...");

    // ждём 1 секунду
    await delay(1000);
    console.log("Прошла 1 секунда");

    // ждём ещё 2 секунды
    await delay(2000);
    console.log("Прошло ещё 2 секунды");

    // результат работы функции
    return "Асинхронная операция завершена!";
}

// вызов асинхронной функции
asyncExample().then(result => console.log("Результат:", result));

/*
Теория:
- await можно использовать только внутри async-функции
- await делает так, что JS "ждёт" завершения Promise, но при этом не блокирует остальной код
- async-функция всегда возвращает Promise
*/


/*---------------------------------------------------
  7. Promises
---------------------------------------------------
Promise (обещание) — объект, который представляет результат
асинхронной операции.

У Promise есть 3 состояния:
- pending (ожидание) — операция ещё выполняется
- fulfilled (успешно) — операция завершилась успехом
- rejected (ошибка) — операция завершилась с ошибкой

Создание Promise:
*/

let promise = new Promise((resolve, reject) => {
    // Здесь идёт асинхронная операция
    setTimeout(() => {
        let success = true; // попробуй поменять на false для ошибки

        if (success) {
            resolve("Операция завершилась успешно!"); // вызываем при успехе
        } else {
            reject("Что-то пошло не так..."); // вызываем при ошибке
        }
    }, 1500); // задержка 1.5 секунды
});

/*
Методы Promise:
- .then(result => {...}) — обрабатывает результат (успех)
- .catch(error => {...}) — обрабатывает ошибку
- .finally(() => {...}) — выполняется в любом случае
*/

promise
    .then(result => {
        console.log("then:", result);
        return "Ещё одно значение";
    })
    .then(value => {
        console.log("Второй then:", value);
    })
    .catch(error => {
        console.log("catch:", error);
    })
    .finally(() => {
        console.log("finally: всегда выполняется, даже при ошибке");
    });

/*
Теория:
- Промисы позволяют писать асинхронный код более читаемо
- В отличие от "адских колбэков" (callback hell), промисы позволяют выстраивать цепочки действий
- async/await — это надстройка над промисами, которая позволяет писать асинхронный код "как синхронный"
*/
